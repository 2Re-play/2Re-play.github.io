{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n### 개요 \nreact를 처음으로 입문한다면 흔하디 흔한 투두리스트, 카운터 예제를 가장 많이 보게된다.  \n필자도 react를 투두리스트, 카운터와 같은 예제로 실습을 진행했다.  \n하지만 실제 프로젝트에 들어가면 서버와 비동기 통신을 해야하고, 상태 관리 등등 많은 개념이 필요해진다.  \n좀 더 편한 상태 관리를 위해 redux를 도입하고 비동기 통신을 위해 redux-saga를 이용하게 됐다.  \n하지만 모든 서비스에 필요한 흔하디 흔한 로그인, 회원가입 예제가 없어 처음에 감을 잡기 힘들어 조금이나마 도움이 되기 위해 포스팅하게 됐다.  \n\n간단한 설명만 진행하기 위해 프로젝트 구조화, 예제 코드는 간단하게만 작성한다. \n\n---\n\n### redux action 만들기\n최근에는 redux의 action, reducer등을 하나의 파일에서 작성하는 DUCKS 패턴을 많이 사용하지만  \n필자는 모두 분리 시켰다.  \nredux를 사용한다면 어떠한 변화를 일으키기 위해서는 action이라는 것을 발생시켜줘야한다.  \n액션은 하나의 객체로 표현되면 type이외의 값은 개발자 마음대로 설정할 수 있다.\n필자는 로그인을 위해 필요한 액션을 `SIGNIN_REQUEST` `SIGNIN_SUCCESS` `SIGNIN_FAIL` 3가지로 만들었다.\n\nsrc/redux/actions 디렉토리에 auth.js을 생성한다.  \n액션 생성 함수를 직접 객체를 리턴하는 함수로 작성해도 되지만  \nredux-actions 모듈의 createAction 함수를 사용하면 좀 더 간결하고 쉽게 액션을 생성 할 수 있다.  \ncreatAction으로 액션을 생성할 때 첫번째 인자는 액션 타입, 두번째 인자는 이외의 데이터를 자유롭게 객체로 넣을 수 있다.  \n\n```jsx harmony\nimport { createAction } from 'redux-actions';\n\n// actions\nexport const SIGNIN_REQUEST = 'auth/SIGNIN_REQUEST';\nexport const SIGNIN_SUCCESS = 'auth/SIGNIN_SUCCESS';\nexport const SIGNIN_FAIL = 'auth/SIGNIN_FAIL';\n\n// create actions\nexport const signInRequestAction = createAction(SIGNIN_REQUEST, user => (user));\nexport const signInSuccessAction = createAction(SIGNIN_SUCCESS, token => (token));\nexport const signInFailAction = createAction(SIGNIN_FAIL);\n```\n\n### redux reducer 만들기 \nredux action을 dispatch시켜 상태에 어떠한 변화를 주고 싶다면  \nredux reducer에서 실질적으로 state값을 변경시키는 작업을 진행한다.\n리덕스를 사용할 때 여러개의 리듀서를 만들고 이를 하나의 루트 리듀서(Root Reducer)로 만들 수 있다.\n\nsrc/redux/reducer/auth.js를 생성한다.    \n위에서 3가지로 구분한 액션별로 변경될 state값을 action객체에서 받아 불변성을 유지하면 넣어주면 된다.  \nreducer를 구현할 때 switch문으로 많이들 작성하지만 redux-actions 모듈의 handleActions를 사용하게 되면 좀 더 간결한 코드를 작성할 수 있다.  \n\n```jsx harmony\nimport handleActions from \"redux-actions/es/handleActions\"\nimport {\n    SIGNIN_FAIL,\n    SIGNIN_SUCCESS,\n    SIGNIN_REQUEST\n} from \"../action/auth\"\n\n// state initialize\nconst initialState = {\n    loading : false,\n    payload : {\n        token : ''\n    },\n}\n\n// reducer\nexport default handleActions({\n    [SIGNIN_REQUEST]: (state, action) => ({\n        ...state,\n        loading: true\n    }),\n    [SIGNIN_SUCCESS]: (state, action) => ({\n        ...state,\n        loading: false,\n        payload: {\n            token: action.payload.token\n        }\n    }),\n    [SIGNIN_FAIL]: (state, action) => ({\n        ...state\n    })\n}, initialState);\n```\n\n### root reducer로 여러개의 reducer 합치기\nsrc/redux/reducer/index.js를 생성한다.  \n해당 파일에서는 여러개의 reducer를 root reducer로 합치는 작업을 한다.  \n\n```jsx harmony\nimport { combineReducers } from \"redux\"\nimport auth from \"./auth\"\n\nexport default combineReducers({\n    auth\n});\n```\n\n### saga 구현하기  \nredux-saga는 제너레이터 함수를 구현하여 사용한다.  \nsrc/redux/saga/authSaga.js 파일을 생성한다.  \n\n해당 예제 saga 제너레이터 함수에서는 api 호출 함수가 구현되어있다고 가정한다.  \nredux-saga모듈의 call 함수를 통해 특정 함수를 비동기로 호출할 수 있다.  \nput 함수로 액션을 디스패치할 수 있다.  \n\n```jsx harmony\nimport { call, put, takeEvery } from \"redux-saga/effects\"\nimport { requestSignIn } from \"../apis/auth\"\nimport { SIGNIN_REQUEST } from \"../redux/action/auth\"\nimport { signInSuccessAction, signInFailAction } from \"../redux/action/auth\"\n\nfunction* postSignInSaga(action) {\n    try {\n        const email = action.payload.id;\n        const password = action.payload.pw;\n        const result = yield call(requestSignIn, email, password); // call 을 사용하면 특정 함수를 호출하고, 결과물이 반환 될 때까지 기다려줄 수 있다.\n        if(result.message === \"SUCCESS\") {\n            yield put(signInSuccessAction({token : result.data.token})); // 성공 액션 디스패치\n        } else {\n            yield put(signInFailAction({error: \"로그인 실패\"})); // 실패 액션 디스패치\n        }\n    } catch (e) {\n        yield put(signInFailAction({error: e.message})); // 실패 액션 디스패치\n    }\n}\n\n// 사가들을 합치기\nexport function* postsSaga() {\n    yield takeEvery(SIGNIN_REQUEST, postSignInSaga);\n}\n```\n\n### root saga로 여러개의 saga 합치기\nsrc/redux/saga/index.js 파일을 생성하여 여러개의 saga를 root saga로 합쳐준다.  \n\n```jsx harmony\nimport { all } from \"../../node_modules/redux-saga/effects\"\nimport { postsSaga } from \"./authSaga\"\n\nexport default function* rootSaga() {\n    yield all([\n      postsSaga(),\n    ]);\n}\n```\n\n### 요약 \n- redux action을 생성하는 코드  \n- 변화된 action을 감지하여 state를 변경해주는 redux reducer 코드\n- 서버로부터 로그인 통신을 하기위한 redux-saga 미들웨어 코드\n를 작성했다.  \n아직까지는 이 모든게 하나로 연결되어 있지 않다!  \n왜냐하면 아직 이 모든 로직이 돌 수 있게 해주는 action을 컴포넌트에 붙이지 않았기 때문이다.  \n다음 포스팅에서 SIGNIN_REQUEST 액션을 디스패치하는 코드와 간단한 로그인 컴포넌트를 만들 예정이다!  \n설명이 부족한 부분이 많아 앞으로 계속해서 수정할 예정이다!  \n\n","excerpt":"개요 react를 처음으로 입문한다면 흔하디 흔한 투두리스트, 카운터 예제를 가장 많이 보게된다. 필자도 react…","fields":{"slug":"/React-login/"},"frontmatter":{"date":"May 11, 2020","title":"[React, Redux, Redux-saga] 흔하디 흔한 투두리스트 아니고 로그인 - 1","tags":["react","redux-saga","redux"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n### [백준 - 1966] 프린터 큐\n\n---\n\n#### 문제 설명\n여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다. 여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다. 하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다.\n\n현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.\n나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄를 한다.\n예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다.\n\n여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다. 예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다.\n\n#### 입력\n첫 줄에 test case의 수가 주어진다.  \n각 test case에 대해서 문서의 수 N(100이하)와 몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue의 어떤 위치에 있는지를 알려주는 M(0이상 N미만)이 주어진다.  \n다음줄에 N개 문서의 중요도가 주어지는데, 중요도는 1 이상 9 이하이다.  \n중요도가 같은 문서가 여러 개 있을 수도 있다.  \n위의 예는 N=4, M=0(A문서가 궁금하다면), 중요도는 2 1 4 3이 된다.\n\n#### 출력 \n각 test case에 대해 문서가 몇 번째로 인쇄되는지 출력한다.\n\n#### 입력 예제\n```\n3\n1 0\n5\n4 2\n1 2 3 4\n6 0\n1 1 9 1 1 1\n```\n\n#### 출력 예제\n```\n1\n2\n5\n```\n\n#### 풀이 \n문제는 어렵지 않았지만..  \n처음에 주먹구구식으로 풀다보니 코드가 너무 더러워져서  \n다시 다 지우고 처음부터 시작했다!  \n\nDocument 클래스안에 원소들의 index와 priority를 저장한 이후에  \n계속해서 큐의 첫번째 원소가 뒤에 더 큰 우선순위를 가진 원소가 있는지 체크했다.  \n\n\n#### 코드 \n\n``` java\npackage baekJoon.BurteForce;\n\nimport java.util.*;\n\nclass Document {\n    int index, priority;\n\n    public Document (int index, int priority) {\n        this.index = index;\n        this.priority = priority;\n    }\n}\n\npublic class B_1966 {\n\n    private static void solution () {\n        Scanner sc = new Scanner(System.in);\n        int testCase = sc.nextInt();\n        int[] result = new int[testCase];\n        for(int i=0; i<testCase; i++) {\n            int n = sc.nextInt();\n            int targetIndex = sc.nextInt();\n            LinkedList<Document> queue = new LinkedList<Document>();\n\n            for(int j=0; j<n; j++) {\n                queue.offer(new Document(j, sc.nextInt()));\n            }\n\n            int count = 1;\n            while(true) {\n                if(isMax(queue)) {\n                    if(queue.getFirst().index == targetIndex) {\n                        result[i] = count;\n                        break;\n                    } else {\n                        queue.poll();\n                        count++;\n                    }\n                } else {\n                    queue.offer(queue.poll());\n                }\n            }\n        }\n\n        for(int item : result) {\n            System.out.println(item);\n        }\n\n    }\n\n    private static boolean isMax (LinkedList<Document> queue) {\n        for(int i=1; i<queue.size(); i++) {\n            if(queue.getFirst().priority < queue.get(i).priority) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        solution();\n    }\n}\n```\n\n","excerpt":"백준 - 1966 프린터 큐 문제 설명 여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다. 여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO…","fields":{"slug":"/BaekJoon-1966/"},"frontmatter":{"date":"Apr 25, 2020","title":"[백준 - 1966] 프린터 큐 ","tags":["알고리즘","BruteForce"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n### [백준 - 11051] 이항계수 2\n\n---\n\n#### 문제 설명\n자연수 N 과 정수 K 가 주어졌을 때 이항 계수를 10,007로 나눈 나머지를 구하는 프로그램을 작성하시오.\n\n#### 입력\n첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 1,000, 0 ≤ K ≤ N)\n\n#### 출력 \nN K 이항계수를 10,007로 나눈 나머지를 출력한다.\n\n#### 입력 예제\n```\n5 2\n```\n\n#### 출력 예제\n```\n10\n```\n\n#### 풀이 \n오랜만에 수학개념이 나와서 이항계수 개념을 다시 보고왔다..ㅎㅎ\n이항계수를 계속해서 나열해보면서 규칙을 찾아봤지만 실패..  \n구글이 주는 조금의 힌트를 얻어서 풀었다!  \n파스칼 삼각형! 정말 이거면 이 문제 그냥 풀린다..!!ㅎㅎ\n\n#### 코드 \n\n``` java\npackage baekJoon.DP;\n\nimport java.util.Scanner;\n\npublic class B_11051 {\n\n    private static void solutiuon () {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[][] dp = new int[n+1][n+1];\n\n            for(int i=0 ; i<=n; i++) {\n                for(int j=0; j<=i; j++) {\n                    if(i == j || j == 0) {\n                        dp[i][j] = 1;\n                    } else {\n                        dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % 10007;\n                    }\n                }\n            }\n\n        System.out.println(dp[n][k]);\n    }\n\n    public static void main(String[] args) {\n        solutiuon();\n    }\n}\n\n```\n\n","excerpt":"백준 - 11051 이항계수 2 문제 설명 자연수 N 과 정수 K 가 주어졌을 때 이항 계수를 10,007로 나눈 나머지를 구하는 프로그램을 작성하시오. 입력 첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 1,000, 0 ≤ K ≤ N) 출력 N K…","fields":{"slug":"/BaekJoon-11051/"},"frontmatter":{"date":"Apr 25, 2020","title":"[백준 - 11051] 이항계수 2","tags":["알고리즘","DP"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n### Redux란\n---\n\n- 가장 사용률이 높은 상태 관리 라이브러리\n- 컴포넌트들의 상태 관련 로직들을 다른 파일로 분리시켜서 더욱 효율적으로 관리 가능\n- 컴포넌트끼리 상태를 공유할 때 여러 컴포넌트를 거치지 않고도 손쉽게 상태 값을 전달 할 수 있다.\n- 상태변화 로직이 들어있는 **스토오**를 통하여, 우리가 원하는 컴포넌트에 원하는 상태값과 함수를 직접 주입할 수 있다.\n\n### Redux에서 자주 사용되는 개념 정리\n---\n\n#### 액션\n- 상태에 어떠한 변화가 필요하게 될 때 액션이라는 것을 발생시킨다.\n- 하나의 객체로 표현하며 액션 객체에는 type필드는 필수로 들어가야한다.\n- 그 외 data는 사용자 마음대로 조정이 가능하다.\n```js\n{\n  type : \"ADD_TODO\",\n  data : {\n      id : 0,\n      text : \"리덕스 배우기\"\n    }\n}\n```\n\n#### 액션 생성함수 (Action Creator)\n- 액션을 만드는 함수다.\n- 파라미터를 받아와 액션 객체 형태로 만들어주는 책임이 있다.\n- 액션 생성함수를 통해 액션을 생성하는 이유는 따로 있다.\n- 나중에 컴포넌트에서 더욱 쉽게 액션을 발생시키기 위해서다.\n- 때문에 보통 함수 앞에 export 키워드를 통해 다른 파일에서 불러와서 사용한다.\n- 액션 생성함수는 필수적으로 구현요소가 아니다.\n- 액션을 발생 시킬 때 마다 직접 액션 객체를 작성해도 괜찮다.\n```js\nexport const addTodo = (data) => {\n  return {\n    type: \"ADD_TODO\",\n    data\n  };\n}\n```\n\n#### Reducer\n- 리듀서는 state의 변화시키는 역할을 한다.\n- 2가지 파라미터를 받는다.\n- 첫번째를 파라미터는 현재 state값, 두번째 파라미터는 변화를 시키고자 하는 액션 객체\n- 이 2가지 파라미터를 받아 새로운 state를 만든다.\n- 리덕서 리듀서에서는 default문에서는 기존 state를 반환하도록 작성한다.\n- 리덕스를 사용할 때 여러개의 리듀서를 만들고 이를 하나의 루트 리듀서(Root Reducer)로 만들 수 있다.\n```js\nfunction addTodo(state, action) {\n  switch (action.type) {\n    case 'ADD_TODO' :\n      return state.concat(action.todo);\n    default :\n      return state;\n  }\n}\n```\n\n#### Store\n- 리덕스에서 한 애플리케이션에 하나의 스토어를 만들게 된다.\n- 스토어 안에는 현재 앱 상태, 리듀서가 들어있다.\n- 내장 함수도 포함되어 있다.\n\n#### Dispatch\n- 디스패치는 스토어의 내장함수 중 하나다.\n- 디스패치는 액션을 발생 시키는 역할을 한다.\n- dispatch 함수에 액션을 파라미터로 전달한다.\n- 디스패치 함수를 호출하게 되면 스토어는 리듀서 함수를 실행시킨다.\n- 해당 액션을 처리하는 로직이 있다면 액션을 참고하여 새로운 상태를 만들어준다.\n\n#### Subscribe\n- 스토어의 내장함수다.\n- 함수 형태의 값을 파라미터로 받는다.\n- 액션이 디스패치 되었을 때 마다 전달해준 함수가 호출된다.\n\n\n\n","excerpt":"Redux…","fields":{"slug":"/Redux-intro/"},"frontmatter":{"date":"Apr 09, 2020","title":"React - Redux 기본 용어 개념","tags":["react"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n### 프로그래머스 - 기능개발\n\n---\n\n#### 문제 설명\n프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.  \n\n또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.  \n\n먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.  \n\n#### 제한 사항\n작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.  \n작업 진도는 100 미만의 자연수입니다.  \n작업 속도는 100 이하의 자연수입니다.  \n배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.  \n\n#### 입출력 예\n|progresses|speeds|return|\n|:---:|:---:|:---:|\n|[93,30,55]|[1,30,5]|[2,1]|\n\n#### 입출력 예 설명\n첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.  \n두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.  \n세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.  \n\n따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.  \n\n#### 코드 \n\n``` java\nimport java.util.*;\n\npublic class P_functionDevelop {\n\n    public static int[] solution(int[] progresses, int[] speeds) {\n        int [] answer = {};\n        int [] temp = new int[progresses.length];\n        List<Integer> list = new ArrayList<Integer>();\n\n        // 매칭되는 task마다 진행도를 매칭하여 몇일이 걸려야하는지 계산\n        for(int i=0; i<progresses.length; i++) {\n            int count = 0;\n            int sum = progresses[i];\n            while (sum < 100) {\n                sum += speeds[i];\n                count++;\n            }\n            temp[i] = count;\n        }\n\n        // 기준값을 설정하여 뒤에 자신보다 빨리 끝난 일이 있으면 자기의 카운트 ++\n        // 자신보다 큰 값이 나오면 list에 add하고 피봇값 변경\n        int pivot = temp[0];\n        int count = 1;\n        for(int j=1; j<temp.length; j++) {\n            if(temp[j] <= pivot) {\n                count++;\n            } else {\n                list.add(count);\n                pivot = temp[j];\n                count = 1;\n            }\n        }\n        list.add(count);\n\n        answer = new int[list.size()];\n        for(int k=0; k<list.size(); k++) {\n            answer[k] = list.get(k);\n        }\n\n        return answer;\n    }\n\n    public static void main (String[] args) {\n        int[] progresses = {40, 93, 30, 55, 60, 65};\n        int[] speeds = {60, 1, 30, 5, 10, 7};\n        // [1, 2, 3]\n\n        // [2,1]\n        solution(progresses, speeds);\n\n    }\n\n}\n\n```\n\n","excerpt":"프로그래머스 - 기능개발 문제 설명 프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 10…","fields":{"slug":"/Programmers/"},"frontmatter":{"date":"Feb 26, 2020","title":"프로그래머스 - 기능개발","tags":["알고리즘"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n\n\n### Bean 이란?\n\n---\n\n<div>\n<img width=\"400\" height = \"250\" alt=\"img2\" src=\"https://user-images.githubusercontent.com/22942313/66982192-9d192980-f0f0-11e9-9ad1-fd5b24c21d75.png\">\n</div>\n\nSpring을 사용하다보면 bean 이라는 용어가 많이 나오는데 bean에 대해 알아보자.\n\n* 상속을 받지않고 가장 기본적인 field와 getter, setter만 가지고 있는 객체가 bean이다.\n* Spring에서 POJO(plain old java object)는 beans라고 불린다.\n* bean을 생성하기 위해서는 xml config file의 설정을 통해 Spring container에 의해 생성된다.\n* xml config file에서는 bean의 lifecycle과 dependency를 설정할 수 있다.\n* Spring container에서 객체를 생성해주기 때문에 개발자가 new 생성자로 객체를 생성할 필요가 없다.\n* container에 의해 생성된 bean에 접근하기 위해서는 getBean(\"[bean_id]\")로 통해 bean에 대한 reference 값을 가져올 수 있다.\n\n### Spring에서 Bean의 속성\n\n---\n\n* Key attributes\n  - class(required) : 클래스의 이름을 속성에 반드시 넣어줘야한다.\n  - id : 해당 bean의 유니크한 값\n  - scope : 객체의 scope (singleton, prototype) **singleton에 대해서 추가공부**\n  - constructor-arg : bean을 생성할 때 constructor에게 넘겨줄 인자, 이를 통해 의존성을 주입한다.\n  - property : bean을 생성할 때 setter메소드를 호출하고 setter의 인자값으로 value로 넘겨준다.\n  - init, destroy method\n\n  \n```xml\n<!-- A simple bean definition -->\n<bean id=\"...\" class=\"...\">\n</bean>\n\n<!-- A bean definition with scope-->\n<bean id=\"...\" class=\"...\" scope=\"singleton\">\n</bean>\n\n<!-- A bean definition with property -->\n<bean id=\"...\" class=\"...\">\n\t<property name=\"message\" value=\"Hello World!\"/>\n</bean>\n\n<!-- A bean definition with initialization method -->\n<bean id=\"...\" class=\"...\" init-method=\"...“ >\n</bean>\n```  \n  \n\n### Spring Bean의 Scope\n\n---\n  \n  \n| Bean Scope | 설명 |  \n|:--------:|:--------:|\n| singleton | bean을 단 하나만 생성하여 값을 공유한다(default scopt) |\n| prototype | 매번 새로운 요청 마다 bean을 생성하며 값을 공유하지 않는다. |\n| request | HTTP request의 하나의 bean  |\n| session | HTTP session의 하나의 bean |\n| global-session | gobal HTTP session의 하나의 bean |  \n\n\n\n* Bean은 2가지의 type을 가지고있다.\n  - singleton\n  - prototype\n* 'singleton'으로 설정한 객체는 Spring container에서 **단 한번** 생성된다.\n  - singleton 객체는 언제 생성되고 언제 수거될까?\n    - Spring container가 생성될 때 singleton 객체가 생성되고 container가 종료될 때 garbage collercter에 의해 수거된다.\n\n* 'prototype'으로 설정한 객체는 요청 마다 새로운 객체를 생성한다.\n  - 더 이상 사용하지 않는 prototype 객체는 garbage collercter가 메모리를 회수한다.\n\n* 객체의 scope를 정의하지 않을 경우 scope default값이 **singleton**으로 객체가 생성된다.\n\n### Dependency Injection methods\n\n---\n의존성주입을 하는 방법은 2가지가 있다.\n\n* 생성자를 통해 의존성 주입\n* property의 setter를 통해 의존성 주입\n\n### Spring Annotation을 사용하여 설정\n\n---\n\n* Spring 2.5버전 이후로 등장하여 요즘 많이 사용하는 방법이다.\n* xml configuration size를 줄이기 위한 목적으로 annotation이 나왔다.\n* bean wired을 위해 xml을 통해서 설정하는 방법의 대체재로 사용된다.\n* bean의 configuration을 class 자체에 옮겨 class 안에서 직접 의존성을 주입한다.\n* xml을 사용하게 되면 bean을 설정할 때 마다 계속해서 설정을 넣어줘야하는데 annotation으로 좀 더 명시적이고 보기좋은 코드를 만들어준다.\n* xml과 annotation을 둘다 사용한다면 xml이 annotaion을 override하게 된다, 즉! xml이 우선순위다.\n\n그렇다면 대표적인 Spring Annotation 몇가지에 대해 알아보자.\n\n첫번째로 Spring Annotation을 사용하기 위해서 Spring Annotation을 활성화 시켜줘야한다.\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    ...\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    ...\n\n   <context:annotation-config/>\n```\n* xmlns:context=\"http://www.springframework.org/schema/context\"\n* <context:annotation-config/>\n\n위 2개의 코드를 web.xml에 추가시켜 Spring Annotation을 활성화 시켰다.\n\n#### @Required Annotation\n\nsetter 메소드에서 인자를 반드시 받아야할 경우 사용하는 어노테이션\n```java\npublic class Boy {\n private String name;\n private int age;\n\n @Required\n public void setName(String name){\n  this.name = name;\n }\n\n @Required\n public void setAge(int age){\n  this.age = age;\n }\n\n //   getters ...\n}\n```\n위 코드에서 setName, setAge 메소드에 @Required 어노테이션이 설정되어 있기 때문에,\nname과 age는 반드시 필수로 주입시켜줘야한다.\n\n```xml\n<bean id=\"boy\" class=\"Boy\">\n <property name=\"name\" value=\"Rony\"/>\n <property name=\"age\" value=\"10\"/>\n</bean>\n```\n위의 의존성 주입은 @Required로 설정된 name과 age를 두개다 **필수**로 주입해줘야한다.\n```xml\n<!-- Property 'age' is required for bean 'boy' -->\n<bean id=\"boy\" class=\"Boy\">\n <property name=\"name\" value=\"Rony\"/>\n</bean>\n```\n위의 의존성 주입은 @Required로 설정된 age를 주입해주지 않았기 때문에 **에러**가 발생한다.\n\n#### @Autowired Annotation\n\n자동적으로 의존성주입을 시키기 위한 어노테이션\n\n1) xml을 사용하여 의존성을 주입하는 방법\n```java\npublic class Boy {\n private String name;\n private int age;\n\n //   getters and setters ...\n}\n```\n\n```java\npublic class College {\n\n private Boy student;\n\n public void setStudent(Boy aboy){\n  this.stuendt = aboy;\n }\n}\n```\n\n```xml\n<bean id=\"boy\" class=\"Boy\">\n <property name=\"name\" value=\"Rony\"/>\n <property name=\"age\" value=\"10\"/>\n</bean>\n\n<bean id=\"college\" class=\"College\">\n  <property name=\"student\" ref=\"boy\"/>\n</bean>\n```\n\nxml파일에서 <property name=\"student\" ref=\"boy\"/> property의 ref값에 주입시킬 bean의 id를 명시하여 의존성주입을 한다.\n\n#### @Autowired\n2) 어노테이션을 사용하여 의존성을 주입하는 방범\n\ntype에 의해서 자동적으로 의존성을 주입해준다.\n\n```java\npublic class Boy {\n private String name;\n private int age;\n\n //   getters and setters ...\n}\n```\n\n```java\npublic class College {\n\n @Autowired\n private Boy student;\n}\n```\n\n```xml\n<bean id=\"boy\" class=\"Boy\">\n <property name=\"name\" value=\"Rony\"/>\n <property name=\"age\" value=\"10\"/>\n</bean>\n\n<bean id=\"college\" class=\"College\">\n</bean>\n```\nCollege 클래스의 student 필드에 **@Autowired** 어노테이션을 사용하여 Boy라는 type을 가진 bean을 주입한다.\n\n##### 하지만!!, 만약 같은 type을 가진 bean이 여러개일때는 Spring container가 값을 어떻게 주입할까?? 이 경우에는 Spring Container는 값을 주입하지 않고 에러를 발생시킨다.  이 문제를 @Qualifier 어노테이션을 사용하여 해결할 수 있다.\n\n\n#### @Qualifier\n\n위에서 말한 상황에서 마법사같이 해결해줄 수 있는 어노테이션이 @Qualifier다.\n같은 type의 객체가 1개 이상일 경우 어떠한 bean을 주입할지 모호하기 때문에\nqulifier value를 통해 구분하여 자동적으로 주입하게 한다.\n\n\n```java\npublic class Boy {\n private String name;\n private int age;\n\n //   getters and setters ...\n}\n```\n```java\npublic class College {\n\n@Autowired\n@Qualifier(value=\"tony\")\n private Boy student;\n\n  //   getters ...\n}\n```\n\n```xml\n<bean id=\"boy1\" class=\"Boy\">\n <qualifier value=\"rony\"/>\n <property name=\"name\" value=\"Rony\"/>\n <property name=\"age\" value=\"10\"/>\n</bean>\n\n<bean id=\"boy2\" class=\"Boy\">\n <qualifier value=\"tony\"/>\n <property name=\"name\" value=\"Tony\"/>\n <property name=\"age\" value=\"8\"/>\n</bean>\n\n<bean id=\"college\" class=\"College\">\n</bean>\n```\nCollege 클래스에서 @Qualifier(value=\"tony\")로 어노테이션을 추가하였다.\nQualifier는 type으로 bean을 찾아 의존성을 주입하지 않고 <qualifier value=\"tony\"/>의 value값으로 구분해서 주입한다.\n\n#### @Resouce\n\n@Autowired 어노테이션과 기능은 비슷하지만 다른 점이 있다.\n@Autowired 는 bean의 type에 따라 의존성주입을 하지만, @Resource 어노테이션은 beand의 unique한 id값을 통해 해당 bean을 의존성주입한다.\n그렇다면, 어차피 @Autowired와 기능도 똑같고 같은 type의 bean이 여러개일 때 걱정도 안해도 되는 @Resource 어노테이션보다 왜 @Autowired 어노테이션을 더 많이 사용할까?\n그 답은 Spring에서는 대부분 singleton bean으로 단 하나의 객체만을 생성하기 때문에 @Autowired 어노테이션을 더 자주 사용한다.\n\n```java\npublic class College {\n\n  @Resource(name=\"boy1\")\n  private Boy student;\n\n  //   getters and setters ...\n}\n```\n\n```xml\n<bean id=\"boy1\" class=\"Boy\">\n <property name=\"name\" value=\"Rony\"/>\n <property name=\"age\" value=\"10\"/>\n</bean>\n\n<bean id=\"boy2\" class=\"Boy\">\n <property name=\"name\" value=\"Tony\"/>\n <property name=\"age\" value=\"8\"/>\n</bean>\n\n<bean id=\"college\" class=\"College\">\n</bean>\n```\n\nxml파일에서 bean의 unique한 id값을 @Resource(name=\"boy1\")의 name값으로 bean의 id를 값으로 넘겨 해당 bean을 의존성주입한다.\n","excerpt":"Bean 이란? Spring을 사용하다보면 bean 이라는 용어가 많이 나오는데 bean에 대해 알아보자. 상속을 받지않고 가장 기본적인 field와 getter, setter만 가지고 있는 객체가 bean이다. Spring에서 POJO(plain…","fields":{"slug":"/Spring-bean-annotation/"},"frontmatter":{"date":"Oct 17, 2019","title":"Spring - Bean, Bean Scope, Spring Annotation","tags":["spring"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# SPRING\n## Dependency Injection\n\n### Dependency Injection 이란?\nA클래스에서 B클래스에게 의존(depend)을 할 경우, 내부에 존재하는 필드(멤버 변수)에게 외부에서 값을 주입시켜주는 것을 말한다.\n위에 말로는 설명이 부족하다. 아래 코드를 보며 이해해보겠다.\n\n``` java\npublic class PetOwner {\n    private AnimalType animal;\n    \n    public PetOwner() {\n        /* 의존성 주입에서는 new 생성자를 사용하지 않는다. */\n        this.animal = new Dog(); \n    }\n}\n```\n위의 코드는 의존성주입이 아닌 의존성 주입을 이해하기 위한 코드이다.  \n위에 코드를 보면 현재 PetOwner()객체는 AnimalType객체에게 의존하고있다.\n이러한 의존을 **의존성**이라고 하며, animal이라는 필드에게 값을 외부에서 넣어주는 것을 **주입**이라고한다.  \n이 말을 합쳐 **의존성 주입, Dependency Injection**이라고 말한다.   \nDI는 Spring framework에 의해 지원하는 디자인패턴이다.  \nDI를 통해 많은 객체들 사이의 coupling을 줄이고 framework에 의해 동적으로 의존성을 주입할 수 있다.\n \n이제 좀 더 **의존성 주입**에 대해 알아보자.  \n\n<div>\n<img width=\"300\" height = \"250\" src=\"https://user-images.githubusercontent.com/22942313/66917998-60e6ba00-f059-11e9-8173-66c7914215be.png\">\n</div>\n\n위 그림을 보게되 Spring Container에서 각각의 객체 Bean A와 Bean B를 생성하고 A객체에서 B객체 사이에 외부에서 **의존성 주입**을한다. \n이러한 설정은 위 그림에서는 xml config 파일 설정으로 한다.  \n위 그림을 코드로 살펴보자.\n\n```java\npublic class Dog implements AnimalType {\n    ...\n    }\n```\n\n```java\npublic class Cat implements AnimalType {\n    ...   \n    }\n```\n\n```java\npublic class PetOwner {\n    private AnimalType animal;\n    \n    public PetOwner(AnimalType animal){\n        this.animal = animal;\n        }\n    }\n```\n\n\nBean Container에서는 위와 같이 Cat, Dog 객체를 생성한 후 PetOwner객체로 AnimalType의 animal필드에게 의존성주입을 하게된다.\n\n### Spring Container\nSpring Container는 Spring 프레임워크의 핵심 컴포넌트이다.\n주요기능으로 1. 객체를 생성 및 관리 2.객체의 의존성 주입이 있다.  \nSpring Container는 xml과 annotations등으로 표현할 수 있다.\n객체를 관리하기 위해서 Container는 DI를 사용한다.\n\n또한, Spring Container는 2가지의 타입이 있는데\n* BeanFactory\n* ApplicationContext  \n로 나뉜다.  \n\n<div>\n<img width=\"400\" height = \"250\" alt=\"img2\" src=\"https://user-images.githubusercontent.com/22942313/66918015-6a702200-f059-11e9-9f54-f16c559b995c.png\">\n</div>\nApplicationContext를 사용하여 container를 생성할 때는 아래의 코드를 사용한다.\n\n```java\nApplicationContext context = new ClassPathXmlApplicationContext(\"[xml config path]\");\n\nPetOwner person = (PetOwner) context.getBean(\"[bean id]\");\n```\n\nnew ClassPathXmlApplicationContext()의 인자로 xml config파일 경로를 넣어주고, context.getBean()메소드를 통해 bean의 id를 인자로 넘겨\nbean을 받아온다.  \n\n### Spring Container와 Dependecy Injection 순서도\n\n<div>\n<img width=\"400\" height = \"350\" alt=\"img3\" src=\"https://user-images.githubusercontent.com/22942313/66918153-adca9080-f059-11e9-9a56-b66015b81659.png\">\n</div>\n위 그림을 설명하자면 main함수가 호출된 이후에 ApplicationContext가 container를 생성하고 생성된 container가 Dog객체와 Cat객체를 생성한다. 이후에 PetOwneranimal 클래스에서 의존성주입을 한다.\n\n\n### Dependency Injection의 장점\n* 의존성을 줄일 수 있다.\n  - 의존성의 감소는 모든 코드를 수정해야하는 번거러운 일 감소에 비례한다.(즉, DI를 통해 많은 코드를 수정하지 않을 수 있다.)\n* 코드의 재사용성\n  - 어떠한 인터페이스가 다른 곳에서도 구현이 필요할 경우 DI를 통해 코드를 변경할 필요가 없다.\n* 읽기 쉬운 코드를 만들어준다.\n* 테스트에 용이하다.\n* 결합도(coupling)을 줄이면서 확장성을 높일 수 있다.  \n등등 정말 수도 없이 많은 장점이 있다.\n\n","excerpt":"SPRING Dependency Injection Dependency Injection 이란? A클래스에서 B클래스에게 의존(depend…","fields":{"slug":"/DI/"},"frontmatter":{"date":"Oct 16, 2010","title":"Spring - Dependency Injection","tags":["spring"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}}}