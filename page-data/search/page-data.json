{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n### 프로그래머스 - 기능개발\n\n---\n\n#### 문제 설명\n프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.  \n\n또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.  \n\n먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.  \n\n#### 제한 사항\n작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.  \n작업 진도는 100 미만의 자연수입니다.  \n작업 속도는 100 이하의 자연수입니다.  \n배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.  \n\n#### 입출력 예\n|progresses|speeds|return|\n|:---:|:---:|:---:|\n|[93,30,55]|[1,30,5]|[2,1]|\n\n#### 입출력 예 설명\n첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.  \n두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.  \n세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.  \n\n따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.  \n\n#### 코드 \n\n``` java\nimport java.util.*;\n\npublic class P_functionDevelop {\n\n    public static int[] solution(int[] progresses, int[] speeds) {\n        int [] answer = {};\n        int [] temp = new int[progresses.length];\n        List<Integer> list = new ArrayList<Integer>();\n\n        // 매칭되는 task마다 진행도를 매칭하여 몇일이 걸려야하는지 계산\n        for(int i=0; i<progresses.length; i++) {\n            int count = 0;\n            int sum = progresses[i];\n            while (sum < 100) {\n                sum += speeds[i];\n                count++;\n            }\n            temp[i] = count;\n        }\n\n        // 기준값을 설정하여 뒤에 자신보다 빨리 끝난 일이 있으면 자기의 카운트 ++\n        // 자신보다 큰 값이 나오면 list에 add하고 피봇값 변경\n        int pivot = temp[0];\n        int count = 1;\n        for(int j=1; j<temp.length; j++) {\n            if(temp[j] <= pivot) {\n                count++;\n            } else {\n                list.add(count);\n                pivot = temp[j];\n                count = 1;\n            }\n        }\n        list.add(count);\n\n        answer = new int[list.size()];\n        for(int k=0; k<list.size(); k++) {\n            answer[k] = list.get(k);\n        }\n\n        return answer;\n    }\n\n    public static void main (String[] args) {\n        int[] progresses = {40, 93, 30, 55, 60, 65};\n        int[] speeds = {60, 1, 30, 5, 10, 7};\n        // [1, 2, 3]\n\n        // [2,1]\n        solution(progresses, speeds);\n\n    }\n\n}\n\n```\n\n","excerpt":"프로그래머스 - 기능개발 문제 설명 프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 10…","fields":{"slug":"/Programmers/"},"frontmatter":{"date":"Feb 26, 2020","title":"프로그래머스 - 기능개발","tags":["알고리즘"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n\n\n### Bean 이란?\n\n---\n\n<div>\n<img width=\"400\" height = \"250\" alt=\"img2\" src=\"https://user-images.githubusercontent.com/22942313/66982192-9d192980-f0f0-11e9-9ad1-fd5b24c21d75.png\">\n</div>\n\nSpring을 사용하다보면 bean 이라는 용어가 많이 나오는데 bean에 대해 알아보자.\n\n* 상속을 받지않고 가장 기본적인 field와 getter, setter만 가지고 있는 객체가 bean이다.\n* Spring에서 POJO(plain old java object)는 beans라고 불린다.\n* bean을 생성하기 위해서는 xml config file의 설정을 통해 Spring container에 의해 생성된다.\n* xml config file에서는 bean의 lifecycle과 dependency를 설정할 수 있다.\n* Spring container에서 객체를 생성해주기 때문에 개발자가 new 생성자로 객체를 생성할 필요가 없다.\n* container에 의해 생성된 bean에 접근하기 위해서는 getBean(\"[bean_id]\")로 통해 bean에 대한 reference 값을 가져올 수 있다.\n\n### Spring에서 Bean의 속성\n\n---\n\n* Key attributes\n  - class(required) : 클래스의 이름을 속성에 반드시 넣어줘야한다.\n  - id : 해당 bean의 유니크한 값\n  - scope : 객체의 scope (singleton, prototype) **singleton에 대해서 추가공부**\n  - constructor-arg : bean을 생성할 때 constructor에게 넘겨줄 인자, 이를 통해 의존성을 주입한다.\n  - property : bean을 생성할 때 setter메소드를 호출하고 setter의 인자값으로 value로 넘겨준다.\n  - init, destroy method\n\n  \n```xml\n<!-- A simple bean definition -->\n<bean id=\"...\" class=\"...\">\n</bean>\n\n<!-- A bean definition with scope-->\n<bean id=\"...\" class=\"...\" scope=\"singleton\">\n</bean>\n\n<!-- A bean definition with property -->\n<bean id=\"...\" class=\"...\">\n\t<property name=\"message\" value=\"Hello World!\"/>\n</bean>\n\n<!-- A bean definition with initialization method -->\n<bean id=\"...\" class=\"...\" init-method=\"...“ >\n</bean>\n```  \n  \n\n### Spring Bean의 Scope\n\n---\n  \n  \n| Bean Scope | 설명 |  \n|:--------:|:--------:|\n| singleton | bean을 단 하나만 생성하여 값을 공유한다(default scopt) |\n| prototype | 매번 새로운 요청 마다 bean을 생성하며 값을 공유하지 않는다. |\n| request | HTTP request의 하나의 bean  |\n| session | HTTP session의 하나의 bean |\n| global-session | gobal HTTP session의 하나의 bean |  \n\n\n\n* Bean은 2가지의 type을 가지고있다.\n  - singleton\n  - prototype\n* 'singleton'으로 설정한 객체는 Spring container에서 **단 한번** 생성된다.\n  - singleton 객체는 언제 생성되고 언제 수거될까?\n    - Spring container가 생성될 때 singleton 객체가 생성되고 container가 종료될 때 garbage collercter에 의해 수거된다.\n\n* 'prototype'으로 설정한 객체는 요청 마다 새로운 객체를 생성한다.\n  - 더 이상 사용하지 않는 prototype 객체는 garbage collercter가 메모리를 회수한다.\n\n* 객체의 scope를 정의하지 않을 경우 scope default값이 **singleton**으로 객체가 생성된다.\n\n### Dependency Injection methods\n\n---\n의존성주입을 하는 방법은 2가지가 있다.\n\n* 생성자를 통해 의존성 주입\n* property의 setter를 통해 의존성 주입\n\n### Spring Annotation을 사용하여 설정\n\n---\n\n* Spring 2.5버전 이후로 등장하여 요즘 많이 사용하는 방법이다.\n* xml configuration size를 줄이기 위한 목적으로 annotation이 나왔다.\n* bean wired을 위해 xml을 통해서 설정하는 방법의 대체재로 사용된다.\n* bean의 configuration을 class 자체에 옮겨 class 안에서 직접 의존성을 주입한다.\n* xml을 사용하게 되면 bean을 설정할 때 마다 계속해서 설정을 넣어줘야하는데 annotation으로 좀 더 명시적이고 보기좋은 코드를 만들어준다.\n* xml과 annotation을 둘다 사용한다면 xml이 annotaion을 override하게 된다, 즉! xml이 우선순위다.\n\n그렇다면 대표적인 Spring Annotation 몇가지에 대해 알아보자.\n\n첫번째로 Spring Annotation을 사용하기 위해서 Spring Annotation을 활성화 시켜줘야한다.\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    ...\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    ...\n\n   <context:annotation-config/>\n```\n* xmlns:context=\"http://www.springframework.org/schema/context\"\n* <context:annotation-config/>\n\n위 2개의 코드를 web.xml에 추가시켜 Spring Annotation을 활성화 시켰다.\n\n#### @Required Annotation\n\nsetter 메소드에서 인자를 반드시 받아야할 경우 사용하는 어노테이션\n```java\npublic class Boy {\n private String name;\n private int age;\n\n @Required\n public void setName(String name){\n  this.name = name;\n }\n\n @Required\n public void setAge(int age){\n  this.age = age;\n }\n\n //   getters ...\n}\n```\n위 코드에서 setName, setAge 메소드에 @Required 어노테이션이 설정되어 있기 때문에,\nname과 age는 반드시 필수로 주입시켜줘야한다.\n\n```xml\n<bean id=\"boy\" class=\"Boy\">\n <property name=\"name\" value=\"Rony\"/>\n <property name=\"age\" value=\"10\"/>\n</bean>\n```\n위의 의존성 주입은 @Required로 설정된 name과 age를 두개다 **필수**로 주입해줘야한다.\n```xml\n<!-- Property 'age' is required for bean 'boy' -->\n<bean id=\"boy\" class=\"Boy\">\n <property name=\"name\" value=\"Rony\"/>\n</bean>\n```\n위의 의존성 주입은 @Required로 설정된 age를 주입해주지 않았기 때문에 **에러**가 발생한다.\n\n#### @Autowired Annotation\n\n자동적으로 의존성주입을 시키기 위한 어노테이션\n\n1) xml을 사용하여 의존성을 주입하는 방법\n```java\npublic class Boy {\n private String name;\n private int age;\n\n //   getters and setters ...\n}\n```\n\n```java\npublic class College {\n\n private Boy student;\n\n public void setStudent(Boy aboy){\n  this.stuendt = aboy;\n }\n}\n```\n\n```xml\n<bean id=\"boy\" class=\"Boy\">\n <property name=\"name\" value=\"Rony\"/>\n <property name=\"age\" value=\"10\"/>\n</bean>\n\n<bean id=\"college\" class=\"College\">\n  <property name=\"student\" ref=\"boy\"/>\n</bean>\n```\n\nxml파일에서 <property name=\"student\" ref=\"boy\"/> property의 ref값에 주입시킬 bean의 id를 명시하여 의존성주입을 한다.\n\n#### @Autowired\n2) 어노테이션을 사용하여 의존성을 주입하는 방범\n\ntype에 의해서 자동적으로 의존성을 주입해준다.\n\n```java\npublic class Boy {\n private String name;\n private int age;\n\n //   getters and setters ...\n}\n```\n\n```java\npublic class College {\n\n @Autowired\n private Boy student;\n}\n```\n\n```xml\n<bean id=\"boy\" class=\"Boy\">\n <property name=\"name\" value=\"Rony\"/>\n <property name=\"age\" value=\"10\"/>\n</bean>\n\n<bean id=\"college\" class=\"College\">\n</bean>\n```\nCollege 클래스의 student 필드에 **@Autowired** 어노테이션을 사용하여 Boy라는 type을 가진 bean을 주입한다.\n\n##### 하지만!!, 만약 같은 type을 가진 bean이 여러개일때는 Spring container가 값을 어떻게 주입할까?? 이 경우에는 Spring Container는 값을 주입하지 않고 에러를 발생시킨다.  이 문제를 @Qualifier 어노테이션을 사용하여 해결할 수 있다.\n\n\n#### @Qualifier\n\n위에서 말한 상황에서 마법사같이 해결해줄 수 있는 어노테이션이 @Qualifier다.\n같은 type의 객체가 1개 이상일 경우 어떠한 bean을 주입할지 모호하기 때문에\nqulifier value를 통해 구분하여 자동적으로 주입하게 한다.\n\n\n```java\npublic class Boy {\n private String name;\n private int age;\n\n //   getters and setters ...\n}\n```\n```java\npublic class College {\n\n@Autowired\n@Qualifier(value=\"tony\")\n private Boy student;\n\n  //   getters ...\n}\n```\n\n```xml\n<bean id=\"boy1\" class=\"Boy\">\n <qualifier value=\"rony\"/>\n <property name=\"name\" value=\"Rony\"/>\n <property name=\"age\" value=\"10\"/>\n</bean>\n\n<bean id=\"boy2\" class=\"Boy\">\n <qualifier value=\"tony\"/>\n <property name=\"name\" value=\"Tony\"/>\n <property name=\"age\" value=\"8\"/>\n</bean>\n\n<bean id=\"college\" class=\"College\">\n</bean>\n```\nCollege 클래스에서 @Qualifier(value=\"tony\")로 어노테이션을 추가하였다.\nQualifier는 type으로 bean을 찾아 의존성을 주입하지 않고 <qualifier value=\"tony\"/>의 value값으로 구분해서 주입한다.\n\n#### @Resouce\n\n@Autowired 어노테이션과 기능은 비슷하지만 다른 점이 있다.\n@Autowired 는 bean의 type에 따라 의존성주입을 하지만, @Resource 어노테이션은 beand의 unique한 id값을 통해 해당 bean을 의존성주입한다.\n그렇다면, 어차피 @Autowired와 기능도 똑같고 같은 type의 bean이 여러개일 때 걱정도 안해도 되는 @Resource 어노테이션보다 왜 @Autowired 어노테이션을 더 많이 사용할까?\n그 답은 Spring에서는 대부분 singleton bean으로 단 하나의 객체만을 생성하기 때문에 @Autowired 어노테이션을 더 자주 사용한다.\n\n```java\npublic class College {\n\n  @Resource(name=\"boy1\")\n  private Boy student;\n\n  //   getters and setters ...\n}\n```\n\n```xml\n<bean id=\"boy1\" class=\"Boy\">\n <property name=\"name\" value=\"Rony\"/>\n <property name=\"age\" value=\"10\"/>\n</bean>\n\n<bean id=\"boy2\" class=\"Boy\">\n <property name=\"name\" value=\"Tony\"/>\n <property name=\"age\" value=\"8\"/>\n</bean>\n\n<bean id=\"college\" class=\"College\">\n</bean>\n```\n\nxml파일에서 bean의 unique한 id값을 @Resource(name=\"boy1\")의 name값으로 bean의 id를 값으로 넘겨 해당 bean을 의존성주입한다.\n","excerpt":"Bean 이란? Spring을 사용하다보면 bean 이라는 용어가 많이 나오는데 bean에 대해 알아보자. 상속을 받지않고 가장 기본적인 field와 getter, setter만 가지고 있는 객체가 bean이다. Spring에서 POJO(plain…","fields":{"slug":"/Spring-bean-annotation/"},"frontmatter":{"date":"Oct 17, 2019","title":"Spring - Bean, Bean Scope, Spring Annotation","tags":["spring"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# SPRING\n## Dependency Injection\n\n### Dependency Injection 이란?\nA클래스에서 B클래스에게 의존(depend)을 할 경우, 내부에 존재하는 필드(멤버 변수)에게 외부에서 값을 주입시켜주는 것을 말한다.\n위에 말로는 설명이 부족하다. 아래 코드를 보며 이해해보겠다.\n\n``` java\npublic class PetOwner {\n    private AnimalType animal;\n    \n    public PetOwner() {\n        /* 의존성 주입에서는 new 생성자를 사용하지 않는다. */\n        this.animal = new Dog(); \n    }\n}\n```\n위의 코드는 의존성주입이 아닌 의존성 주입을 이해하기 위한 코드이다.  \n위에 코드를 보면 현재 PetOwner()객체는 AnimalType객체에게 의존하고있다.\n이러한 의존을 **의존성**이라고 하며, animal이라는 필드에게 값을 외부에서 넣어주는 것을 **주입**이라고한다.  \n이 말을 합쳐 **의존성 주입, Dependency Injection**이라고 말한다.   \nDI는 Spring framework에 의해 지원하는 디자인패턴이다.  \nDI를 통해 많은 객체들 사이의 coupling을 줄이고 framework에 의해 동적으로 의존성을 주입할 수 있다.\n \n이제 좀 더 **의존성 주입**에 대해 알아보자.  \n\n<div>\n<img width=\"300\" height = \"250\" src=\"https://user-images.githubusercontent.com/22942313/66917998-60e6ba00-f059-11e9-8173-66c7914215be.png\">\n</div>\n\n위 그림을 보게되 Spring Container에서 각각의 객체 Bean A와 Bean B를 생성하고 A객체에서 B객체 사이에 외부에서 **의존성 주입**을한다. \n이러한 설정은 위 그림에서는 xml config 파일 설정으로 한다.  \n위 그림을 코드로 살펴보자.\n\n```java\npublic class Dog implements AnimalType {\n    ...\n    }\n```\n\n```java\npublic class Cat implements AnimalType {\n    ...   \n    }\n```\n\n```java\npublic class PetOwner {\n    private AnimalType animal;\n    \n    public PetOwner(AnimalType animal){\n        this.animal = animal;\n        }\n    }\n```\n\n\nBean Container에서는 위와 같이 Cat, Dog 객체를 생성한 후 PetOwner객체로 AnimalType의 animal필드에게 의존성주입을 하게된다.\n\n### Spring Container\nSpring Container는 Spring 프레임워크의 핵심 컴포넌트이다.\n주요기능으로 1. 객체를 생성 및 관리 2.객체의 의존성 주입이 있다.  \nSpring Container는 xml과 annotations등으로 표현할 수 있다.\n객체를 관리하기 위해서 Container는 DI를 사용한다.\n\n또한, Spring Container는 2가지의 타입이 있는데\n* BeanFactory\n* ApplicationContext  \n로 나뉜다.  \n\n<div>\n<img width=\"400\" height = \"250\" alt=\"img2\" src=\"https://user-images.githubusercontent.com/22942313/66918015-6a702200-f059-11e9-9f54-f16c559b995c.png\">\n</div>\nApplicationContext를 사용하여 container를 생성할 때는 아래의 코드를 사용한다.\n\n```java\nApplicationContext context = new ClassPathXmlApplicationContext(\"[xml config path]\");\n\nPetOwner person = (PetOwner) context.getBean(\"[bean id]\");\n```\n\nnew ClassPathXmlApplicationContext()의 인자로 xml config파일 경로를 넣어주고, context.getBean()메소드를 통해 bean의 id를 인자로 넘겨\nbean을 받아온다.  \n\n### Spring Container와 Dependecy Injection 순서도\n\n<div>\n<img width=\"400\" height = \"350\" alt=\"img3\" src=\"https://user-images.githubusercontent.com/22942313/66918153-adca9080-f059-11e9-9a56-b66015b81659.png\">\n</div>\n위 그림을 설명하자면 main함수가 호출된 이후에 ApplicationContext가 container를 생성하고 생성된 container가 Dog객체와 Cat객체를 생성한다. 이후에 PetOwneranimal 클래스에서 의존성주입을 한다.\n\n\n### Dependency Injection의 장점\n* 의존성을 줄일 수 있다.\n  - 의존성의 감소는 모든 코드를 수정해야하는 번거러운 일 감소에 비례한다.(즉, DI를 통해 많은 코드를 수정하지 않을 수 있다.)\n* 코드의 재사용성\n  - 어떠한 인터페이스가 다른 곳에서도 구현이 필요할 경우 DI를 통해 코드를 변경할 필요가 없다.\n* 읽기 쉬운 코드를 만들어준다.\n* 테스트에 용이하다.\n* 결합도(coupling)을 줄이면서 확장성을 높일 수 있다.  \n등등 정말 수도 없이 많은 장점이 있다.\n\n","excerpt":"SPRING Dependency Injection Dependency Injection 이란? A클래스에서 B클래스에게 의존(depend…","fields":{"slug":"/DI/"},"frontmatter":{"date":"Oct 16, 2010","title":"Spring - Dependency Injection","tags":["spring"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}}}